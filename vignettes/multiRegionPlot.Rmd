---
title: "Visualizing signals across many regions"
author: 
- name: Pierre-Luc Germain
  affiliation:
    - D-HEST Institute for Neuroscience, ETH
    - Lab of Statistical Bioinformatics, UZH
package: epiwraps
output:
  BiocStyle::html_document
abstract: |
  This vignette covers the functions necessary for plotting signal across 
  multiple regions. This involves acquiring positional information in/around 
  given regions across tracks, functions to manipulate and aggregate these 
  matrices, as well as functions to plot signal heatmaps from them.
vignette: |
  %\VignetteIndexEntry{multiRegionPlot}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
library(BiocStyle)
```

# Introduction

Since reading data from many regions is typically longer than plotting it, we 
split plotting and acquiring the data. The latter is done through function 
specific to this package, while the former involves especially a wrapper around 
the `r BiocStyle::Biocpkg("EnrichedHeatmap")` package. The interface here has 
been simplified, but for full functionality and customization it is 
recommended to have a look at the `r BiocStyle::Biocpkg("EnrichedHeatmap")` 
documentation.

## Reading signal around a set of regions

The `signal2Matrix` function reads genomic signals around the centers of a set
of regions. It can read from bam and BigWig files, although reading from bam 
files is considerably slower and we strongly recommend using bigwig files.

```{r}
# we fetch the path to the example bigwig file:
bwf <- system.file("extdata/example_atac.bw", package="epiwraps")
# we load example regions (could be a GRanges or a path to a bed-like file):
regions <- system.file("extdata/example_peaks.bed", package="epiwraps")
# we obtain the matrix of the signal around the regions. For the purpose of this
# example, we'll read twice from the same:
m <- signal2Matrix(c(atac1=bwf, atac2=bwf), regions, extend=1000L, binMethod = "mean")
lapply(m,dim)
```

The result is a named list of matrices (more specifically, `normalizedMatrix`
objects, see `r BiocStyle::Biocpkg("EnrichedHeatmap")`) with equal dimensions. 
In this example, the matrix has 264 rows/regions, and 200 columns because we
asked to extend 1000bp on either side, and the default bin size is 10bp.

In addition to the arguments explicitly described in the function's help, it
can accept a number of arguments also accepted by the `normalizeToMatrix` 
function (e.g. `smooth=TRUE`). 

When reading multiple files, the `BPPARAM` argument can be used to set 
multi-threading and increase speed.

### Manipulating signal matrices

The list of signal matrices can be manipulated as any list of matrices, for 
instance using subsetting (e.g. `m[1:2]`), but even using transformations, e.g.:

```{r}
# square-root transform
m2 <- lapply(m, sqrt)
```

For re-normalizing lists of signal matrices, see `?rescaleSignalMatrices` and/or
`?renormalizeBorders`. In addition, signal matrices can be combined either 
manually, or using the following convenience function:

```{r}
merged <- mergeSignalMatrices(m, aggregation="mean")
```

#### Normalization

The `getNormFactors()` function can be used to estimate normalization factors 
using different methods, such as background normalization (aka SSN), 
shared-peaks (aka MAnorm), TMM, S3norm, etc., on a set of either i) bam files or
ii) bigwig files.

The normalization factors can then be applied on signal matrices, for example:

```{r, eval=FALSE}
bwfiles <- c(atac1=bwf, atac2=bwf)
nf <- getNormFactors(bwfiles, method="background")
sm <- signal2Matrix(bwfiles, regions, extend=1000L)
sm2 <- rescaleSignalMatrices(sm, nf)
```


## Plotting heatmaps

Once the matrices have been created (and eventually normalized), we can plot 
heatmaps based on them as follows:

```{r heatmap1, fig.height=4, fig.width=4}
plotEnrichedHeatmaps(m)
# we  can use most arguments that are supported by EnrichedHeatmap, e.g.:
plotEnrichedHeatmaps(m, colors=c("white","darkred"), cluster_rows=TRUE,
                     show_row_dend=TRUE, top_annotation=FALSE, 
                     row_title="My list of cool regions")
```
By default, the colorscale is trimmed to prevent most of it being driven by rare
extreme values. This can be controlled via the `trim` argument (which indicates
up to which quantile of data points to keep to establish the colorscale). 
Compare for instance the following two heatmaps:

```{r heatmapTrim, fig.height=4, fig.width=5}
plotEnrichedHeatmaps(list("trim=1"=m[[1]]), trim=1, scale_title="trim=1",
                     top_annotation=FALSE) +
  plotEnrichedHeatmaps(list("trim=0.99"=m[[1]]), trim=0.99, scale_title="trim=0.99",
                     top_annotation=FALSE) +
  plotEnrichedHeatmaps(list("trim=0.9"=m[[1]]), trim=0.9, 
                       scale_title="trim=0.9", top_annotation=FALSE)
```

The underlying data is exactly the same, only the color-mapping changes. In the 
left one, which has no trimming, a single very high value at the top forces the
colorscale to extend to high values, even though most of the data is in the 
very low range, resulting in a very dark heatmap. In the one on the right, it's
the opposite: so much is trimmed that many points reach the top of the 
colorscale, resulting in a an 'over-exposed' heatmap. In practice, it is 
advisable to use minimal trimming (e.g. the default is `c(0.01,0.99)`,
as in the corresponding DeepTools function).



### Clustering

The traditional ranking by decreasing overall enrichment can easily hide 
patterns in the data, which are instead revealed by clustering. While 
hierarchical clustering can be performed in the plotting function itself, this
is based on the whole enrichment profiles and seldom provides good results in 
practice. For this reason, we provide a function that clusters the rows based on
the distance-weighted enrichment scores. For example:

```{r, eval=FALSE}
# not run
cl <- clusterSignalMatrices(sm2, k=3, scaleRows=TRUE)
mycolors <- c("1"="red", "2"="blue", "3"="darkgreen")
plotEnrichedHeatmaps(sm2, row_split=cl, mean_color=mycolors)
```

Note that here we are splitting into 3 clusters, you can also provide a range
of values (e.g. `k=2:8`) and the function will also return cluster quality 
metrics for each.

[include proper example... Creb family]

## Plotting aggregated signals

It is also possible to plot only the average signals across regions. To do this,
we first melt the signal matrices and then use `r CRANpkg("ggplot2")`. The
`meltSignals` function will return a data.frame showing the mean, standard 
deviation, standard error and median at each position relative to the center,
for each sample/matrix:

```{r}
d <- meltSignals(m)
head(d)
```

This can then be used for plotting. For this example, since it consists of twice the same file, we'll first create a fake difference:

```{r}
# create a fake difference so that there's something to visualize in this example:
d$mean[d$sample=="atac2"] <- 0.06+(d$mean[d$sample=="atac2"]-0.06)*0.6
```

Then we can plot normally with `ggplot`:

```{r aggPlot, fig.width=4, fig.height=3}
library(ggplot2)
ggplot(d, aes(position, mean, colour=sample)) +
  geom_vline(xintercept=0, linetype="dashed") +
  geom_ribbon(aes(position, ymin=mean-SE, ymax=mean+SE, fill=sample), alpha=0.4, colour=NA) + 
  geom_line(size=1.2) + labs(x="relative position", y="mean RPKM")
```


Note that when the regions are clustered, the clusters can be passed to melt and
aggregate separately the different clusters, e.g.:
`d <- meltSignals(m, splitBy=cl)`.
